<!DOCTYPE html>
<html lang="ch">
<head>
    <meta charset="UTF-8">
    <title>js深浅拷贝</title>
</head>
<body>
<script>
    let obj = {
        reg : /^asd$/,
        fun: function(){},
        syb:Symbol('foo'),
        str:'asd',
        arr:[2,3,{a:1,b:2}],
        obj:{a:1, b:{a:2}}
    };
    // -----------深克隆-------------
    // 循环赋值方式实现克隆
    function fun1(obj){
        let newObj = {}
        for (let e in obj) {
            newObj[e] = obj[e]
        }
        console.log(newObj)
    }
    fun1(obj);
    // Object.assign(obj)
    function fun2(obj){
        let newObj = Object.assign(obj)
        console.log(newObj)
    }
    fun2(obj);
    function fun3(obj){
        let newObj = {...obj}
        console.log(newObj)
    }
    fun3(obj);
    let obj = Object.create(obj).obj={}
    console.log()
    console.log(Object.create(obj).obj={})
    // -----------深克隆-------------
    // JSON.parse(JSON.stringify(obj)) 缺点很明显
    let cp = JSON.parse(JSON.stringify(obj));
    console.log(cp);
    // 递归赋值
    function deepCopy(target){
        let copyed_objs = [];//此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象
        function _deepCopy(target){
            if((typeof target !== 'object')||!target){return target;}
            for(let i= 0 ;i<copyed_objs.length;i++){
                if(copyed_objs[i].target === target){
                    return copyed_objs[i].copyTarget;
                }
            }
            let obj = {};
            if(Array.isArray(target)){
                obj = [];//处理target是数组的情况
            }
            copyed_objs.push({target:target,copyTarget:obj})
            Object.keys(target).forEach(key=>{
                if(obj[key]){ return;}
                obj[key] = _deepCopy(target[key]);
            });
            return obj;
        }
        return _deepCopy(target);
    }
    // Object.create()
</script>
</body>
</html>
